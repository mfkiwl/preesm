package org.preesm.codegen.xtend.printer.c.axb

import java.util.Date
import org.preesm.codegen.model.CoreBlock
import org.preesm.codegen.model.SubBuffer
import org.preesm.codegen.model.CallBlock
import org.preesm.codegen.xtend.printer.c.CPrinter
import org.preesm.model.scenario.check.FifoTypeChecker
import org.preesm.model.scenario.check.AxbFifoTypeChecker

/**
 * This printer currently prints C code for X86 cores with all
 * communications made in the shared memory with support for Approximate Buffers.
 *
 * @author hmiomand
 */
class AxBCPrinter extends CPrinter {

	new() {
		// generate a main file
		this(true);
	}

	/**
	 * expose argument to child classes
	 */
	new(boolean generateMainFile) {
		super(generateMainFile)
	}

	override printCoreBlockHeader(CoreBlock block) '''
			/**
			 * @file «block.name».c
			 * @generated by «this.class.simpleName»
			 * @date «new Date»
			 *
			 * Code generated for processing element «block.name» (ID=«block.coreID»).
			 */

			#include "preesm_gen.h"
			#include "ApproximateBuffer.h"

	'''

	override printSubBufferDefinition(SubBuffer buffer) '''
	«IF AxbFifoTypeChecker.isAxbType(buffer.type)»
		char *const «buffer.name + "_axb_segment"» = (char*) («var offset = 0L»«
		{offset = buffer.getOffsetInByte
		 var b = buffer.container;
		 while(b instanceof SubBuffer){
			offset = offset + b.getOffsetInByte
		  	b = b.container
		  }
		 b}.name»+«offset»);  // «buffer.comment» size:= «buffer.getNbToken»*«buffer.type» («buffer.getNbToken»*«AxbFifoTypeChecker.getAxbTokenSize(buffer.type)» bits)

		ApproximateBuffer «buffer.name + "_axb_struct"»;
		void *const «buffer.name» = (void*) &«buffer.name + "_axb_struct"»;

	«ELSE»
		«buffer.type» *const «buffer.name» = («buffer.type»*) («var offset = 0L»«
		{offset = buffer.getOffsetInByte
		 var b = buffer.container;
		 while(b instanceof SubBuffer){
			offset = offset + b.getOffsetInByte
		  	b = b.container
		  }
		 b}.name»+«offset»);  // «buffer.comment» size:= «buffer.getNbToken»*«buffer.type»
	 «ENDIF»
	'''

	override printCoreInitBlockHeader(CallBlock callBlock) '''
		void *computationThread_Core«(callBlock.eContainer as CoreBlock).coreID»(void *arg){
			if (arg != NULL) {
				printf("Warning: expecting NULL arguments\n"); fflush(stdout);
			}

		«FOR buffer : getAllBuffers(printedCoreBlock)»
			// Setting-up Approximate Buffer with token type «buffer.type»
			«IF AxbFifoTypeChecker.isAxbType(buffer.type)»
				«buffer.name + "_axb_struct"».pointerToBuffer = (uint8_t*) «buffer.name + "_axb_segment"»;
				«buffer.name + "_axb_struct"».storageSize = «AxbFifoTypeChecker.getAxbTokenSize(buffer.type)»;
				«buffer.name + "_axb_struct"».workingSize = 32;
				«IF AxbFifoTypeChecker.isAxbFxp(buffer.type)»
					«buffer.name + "_axb_struct"».axbType = FXP;
					«buffer.name + "_axb_struct"».fractionalSize = «AxbFifoTypeChecker.getAxbFxpFractionalSize(buffer.type)»;
					«buffer.name + "_axb_struct"».signBit = «AxbFifoTypeChecker.getAxbSignBit(buffer.type)»;
				«ELSEIF AxbFifoTypeChecker.isAxbCfp(buffer.type)»
					«buffer.name + "_axb_struct"».axbType = CFP;
					«buffer.name + "_axb_struct"».exponentSize = «AxbFifoTypeChecker.getAxbCfpExponentSize(buffer.type)»;
					«buffer.name + "_axb_struct"».mantissaSize = «AxbFifoTypeChecker.getAxbCfpMantissaSize(buffer.type)»;
					«buffer.name + "_axb_struct"».exponentBias = «AxbFifoTypeChecker.getAxbCfpBias(buffer.type)»;
					«buffer.name + "_axb_struct"».signBit = «AxbFifoTypeChecker.getAxbSignBit(buffer.type)»;
				«ELSE»
					«buffer.name + "_axb_struct"».axbType = NO_TYPE;
				«ENDIF»
			«ENDIF»
		«ENDFOR»

		«IF !monitorAllFifoMD5 && !printedCoreBlock.sinkFifoBuffers.isEmpty»
	#ifdef PREESM_MD5_UPDATE
			«FOR buffer : printedCoreBlock.sinkFifoBuffers»
		PREESM_MD5_CTX preesm_md5_ctx_«buffer.name»;
		PREESM_MD5_Init(&preesm_md5_ctx_«buffer.name»);
			«ENDFOR»
	#endif
		«ENDIF»
		«IF !callBlock.codeElts.empty»// Initialisation(s)«"\n\n"»«ENDIF»
		'''
}
